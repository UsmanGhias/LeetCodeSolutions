<!--
// Merge Sort Algorithm 
 // Initial Condition 
 If p<r  
     Then q → ( p+ r)/2  
        MERGE-SORT (A, p, q)  
        MERGE-SORT ( A, q+1,r)  
        MERGE ( A, p, q, r)  

// Merge Sor Algorithm Analysis fo Algorithms
 n1 <-- q - p + 1 
      n2 <-- r - q
      create arrays L[1 ... n1 + 1] and R[1 ... n2 + 1]
      for i <-- 1 to n1
           do L[i] <-- A[p + i - 1]
      for j <-- 1 to n2
          do R[j] <-- A[q + j]
      L[n1 + 1] <-- infinite 
      R[n2 + 1] <-- infinite
      i <-- 1
      j <-- 1
      for k <-- p to r
        do if L[i] <= R[j]
          then A[k] <-- L[i]
                    i <-- i + 1
               else A[k] <-- R[j]
                    j <-- j + 1



 /* // #  Loop #Invariant */
Loop Invariant:

Initialization: prior to the first iteration of the loop, we have k = p, so that subarray A[p ... k - 1] is empty. 
This empty subarray contains the k - p = 0 smallest elements of L and R, and since i = j = 1, both L[i] and R[j] 
are the smallest elements of their arrays that have not been copied back into A.

Maintenance: To see that each iteration maintains the loop invariant, let us first suppose that l[i] <= R[j].
Then L[i] is the smallest element not yet copied back into A. Because A[p ... k - 1] contains the k - p smallest elements,
after line 14 copies L[i] into A[k], the subarray A[p ... k] will contain the k - p + 1 smallest elements.
Incrementing k(in the for loop update) and i(in line 15) re-establishes the loop invariant for the next iteration.
If instead L[i] > R[j], then lines 16-17 perform the appropriate action to maintain the loop invariant.

Termination: At termination, k = r + 1. By the loop invariant, the subarray A[p ... k - 1], which is A[p ... r],
contains the k - p = r - p + 1 smallest elements of L[1 ... n1 + 1] and R[1 ... n2 + 1],
in sorted order. The arrays L and R together contain n1 + n2 + 2 = r - p + 3 elements.
All but the two largest elements have been copied back into A, and these two largest elements are the sentinels.

-->